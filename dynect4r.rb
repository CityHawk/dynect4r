#!/usr/bin/env ruby
################################################################################
# dynect4r - Ruby library and command line client for Dynect REST API
# Copyright (c) 2010 Michael Conigliaro <mike [at] conigliaro [dot] org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
################################################################################

require 'rubygems'
gem 'json', '>=1.4.3'

require 'json'
require 'logger'
require 'optparse'
require 'pp'
require 'set'
require 'rest_client'


module Dynect

  class Client

    # log in, set auth token
    def initialize(params)
      @base_url = 'https://api2.dynect.net'
      @headers = { :content_type => :json, :accept => :json }
      response = rest_call(:post, 'Session', params)
      @headers['Auth-Token'] = response[:data][:token]
    end

    # do a rest call
    def rest_call(action, resource, arguments = nil)

      # set up retry loop
      max_tries = 12
      for try_counter in (1..max_tries)

        # pause between retries
        if try_counter > 1
          sleep(5)
        end

        resource_url = resource_to_url(resource)

        # do rest call
        begin
          response = case action
          when :post, :put
            RestClient.send(action, resource_url, arguments.to_json, @headers) do |res,req|
              Dynect::Response.new(res)
            end
          else
            RestClient.send(action, resource_url, @headers) do |res,req|
              Dynect::Response.new(res)
            end
          end

          # if we got this far, then it's safe to break out of the retry loop
          break

        # on redirect, rewrite rest call params and retry
        rescue RedirectError
          if try_counter < max_tries
            action = :get
            resource = $!.message
            arguments = nil
          else
            raise OperationTimedOut, "Maximum number of tries (%d) exceeded on resource: %s" % [max_tries, resource]
          end
        end

      end

      # return a response object
      response
    end

    private

    # convert the given resource into a proper url
    def resource_to_url(resource)

      # convert into an array
      if resource.is_a? String
        resource = resource.split('/')
      end

      # remove empty elements
      resource.delete('')

      # make sure first element is 'REST'
      if resource[0] != 'REST'
        resource.unshift('REST')
      end

      # prepend base url and convert back to string
      "%s/%s/" % [@base_url, resource.join('/')]
    end

  end

  class Response

    def initialize(response)

      # parse response
      begin
        @hash = JSON.parse(response, :symbolize_names => true)
      rescue JSON::ParserError
        if response =~ /REST\/Job\/[0-9]+/
          raise RedirectError, response
        else
         raise
        end
      end

      # raise error based on error code
      if @hash.has_key?(:msgs)
        @hash[:msgs].each do |msg|
          case msg[:ERR_CD]
          when 'ILLEGAL_OPERATION'
            raise IllegalOperationError, msg[:INFO]
          when 'INTERNAL_ERROR'
            raise InternalErrorError, msg[:INFO]
          when 'INVALID_DATA'
            raise InvalidDataError, msg[:INFO]
          when 'INVALID_REQUEST'
            raise InvalidRequestError, msg[:INFO]
          when 'INVALID_VERSION'
            raise InvalidVersionError, msg[:INFO]
          when 'MISSING_DATA'
            raise MissingDataError, msg[:INFO]
          when 'NOT_FOUND'
            raise NotFoundError, msg[:INFO]
          when 'OPERATION_FAILED'
            raise OperationFailedError, msg[:INFO]
          when 'PERMISSION_DENIED'
            raise PermissionDeniedError, msg[:INFO]
          when 'SERVICE_UNAVAILABLE'
            raise ServiceUnavailableError, msg[:INFO]
          when 'TARGET_EXISTS'
            raise TargetExistsError, msg[:INFO]
          when 'UNKNOWN_ERROR'
            raise UnknownErrorError, msg[:INFO]
          end
        end
      end
    end

    def [](key)
      @hash[key]
    end

  end

  # exceptions generated by class
  class DynectError < StandardError; end
  class RedirectError < DynectError; end
  class OperationTimedOut < DynectError; end

    # exceptions generated by api
  class IllegalOperationError < DynectError; end
  class InternalErrorError < DynectError; end
  class InvalidDataError < DynectError; end
  class InvalidRequestError < DynectError; end
  class InvalidVersionError < DynectError; end
  class MissingDataError < DynectError; end
  class NotFoundError < DynectError; end
  class OperationFailedError < DynectError; end
  class PermissionDeniedError < DynectError; end
  class ServiceUnavailableError < DynectError; end
  class TargetExistsError < DynectError; end
  class UnknownErrorError < DynectError; end

  class Logger < Logger

    # override << operator to control rest_client logging
    # see http://github.com/archiloque/rest-client/issues/issue/34/
    def << (msg)
      debug(msg.strip)
    end
  end

  class << self

    # return the appropriate rest resource for the given rtype
    def rtype_to_resource(rtype)
      rtype.upcase + 'Record'
    end

    # return a hash of arguments for the specified rtype
    def args_for_rtype(rtype, rdata)

      arg_array = case rtype
      when 'A', 'AAAA'
        ['address']
      when 'CNAME'
        ['cname']
      when 'DNSKEY', 'KEY'
        ['flags', 'protocol', 'algorithm', 'public_key']
      when 'DS'
        ['keytag', 'algorithm', 'digtype', 'digest']
      when 'LOC'
        ['version', 'size', 'horiz_pre', 'vert_pre' 'latitude', 'longitude', 'altitude']
      when 'MX'
        ['preference', 'exchange']
      when 'NS'
        ['nsdname']
      when 'PTR'
        ['ptrdname']
      when 'RP'
        ['mbox', 'txtdname']
      when 'SOA'
        ['rname']
      when 'SRV'
        ['priority', 'weight', 'port', 'target']
      when 'TXT'
        ['txtdata']
      else
        []
      end

      if rtype == 'TXT'
        rdata = { arg_array[0] => rdata }
      else
        rdata.split.inject({}) { |memo,obj| memo[arg_array[memo.length]] = obj; memo }
      end
    end

  end

end


# command line client
if __FILE__ == $0

  # set default command line options
  options = {
    :cred_file       => './dynect4r.secret',
    :customer        => nil,
    :username        => nil,
    :password        => nil,
    :zone            => nil,
    :node            => Socket.gethostbyname(Socket.gethostname).first,
    :ttl             => 86400,
    :type            => 'A',
    :rdata           => nil,
    :log_level       => 'info',
    :dry_run         => false,
    :cancel_on_error => false
  }

  # parse command line options
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] [rdata][, ...]\n" \
      + "Example: #{$0} -n srv.example.org -t SRV 0 10 20 target.example.org"

    opts.on('-c', '--credentials-file VALUE', 'Path to file containing API customer/username/password (default: %s)' % options[:cred_file]) do |opt|
      options[:cred_file] = opt
    end

    opts.on('-z', '--zone VALUE', 'DNS Zone (default: Auto-detect)') do |opt|
      options[:zone] = opt
    end

    opts.on('-n', '--node VALUE', 'Node name (default: %s)' % options[:node]) do |opt|
      options[:node] = opt
    end

    opts.on('-s', '--ttl VALUE', 'Time to Live (default: %s)' % options[:ttl]) do |opt|
      options[:ttl] = opt
    end

    opts.on('-t', '--type VALUE', 'Record type (default: %s)' % options[:type]) do |opt|
      options[:type] = opt.upcase
    end

    opts.on('-v', '--verbosity VALUE', 'Log verbosity (default: %s)' % options[:log_level]) do |opt|
      options[:log_level] = opt
    end

    opts.on('--dry-run', "Perform a trial run without making changes (default: %s)" % options[:dry_run]) do |opt|
      options[:dry_run] = opt
    end

    opts.on('--cancel-on-error', "All changes will be canceled if any error occurs (default: %s)" % options[:cancel_on_error]) do |opt|
      options[:cancel_on_error] = opt
    end

  end.parse!
  options[:rdata] = ARGV.join(' ').split(',').collect { |obj| obj.strip() }

  # instantiate logger
  log = Dynect::Logger.new(STDOUT)
  log.level = eval('Dynect::Logger::' + options[:log_level].upcase)
  RestClient.log = log

  # validate command line options
  begin
    (options[:customer_name], options[:user_name], options[:password]) = File.open(options[:cred_file]).readline().strip().split()
  rescue Errno::ENOENT
    log.error('Credentials file does not exist: %s' % options[:cred_file])
    Process.exit(1)
  end
  if !options[:zone]
    options[:zone] = options[:node][(options[:node].index('.') + 1)..-1]
  end

  # track number of changes and errors
  changes = 0
  errors = 0

  # instantiate dynect client and log in
  log.info('Starting session')
  begin
    c = Dynect::Client.new(:customer_name => options[:customer_name],
                           :user_name => options[:user_name],
                           :password => options[:password])
  rescue Dynect::DynectError
    log.error($!.message)
    Process.exit(1)
  end

  # create set of existing records
  begin
    existing_rdata = Set.new
    existing_rdata_urls = {}
    response = c.rest_call(:get, [Dynect::rtype_to_resource(options[:type]), options[:zone], options[:node]])
    response[:data].each do |url|
      rdata = c.rest_call(:get, url)[:data][:rdata].inject({}) { |memo,(k,v)| memo[k.to_s] = v.to_s; memo }
      existing_rdata << rdata
      existing_rdata_urls[rdata] = url
      log.info('Found record (Zone="%s", Node="%s" TTL="%s", Type="%s", RData="%s")' %
        [options[:zone], options[:node], options[:ttl], options[:type], rdata.to_json])
    end
  rescue Dynect::DynectError
    log.error('Query for records failed - %s' % $!.message)
    Process.exit(1)
  end

  # create set of new records
  new_rdata = Set.new
  options[:rdata].each do |rdata|
    new_rdata << Dynect::args_for_rtype(options[:type], rdata)
  end

  # delete records
  (existing_rdata - new_rdata).each do |rdata|
    log.warn('%sDeleting record (Zone="%s", Node="%s" TTL="%s", Type="%s", RData="%s")' %
      [options[:dry_run] ? '(NOT) ' : '', options[:zone], options[:node], options[:ttl], options[:type], rdata.to_json])
    begin
      if not options[:dry_run]
        c.rest_call(:delete, existing_rdata_urls[rdata])
      end
      changes += 1
    rescue Dynect::DynectError
      errors += 1
      log.error('Failed to delete record - %s' % $!.message)
    end
  end

  # add new records
  (new_rdata - existing_rdata).each do |rdata|
    log.warn('%sCreating record (Zone="%s", Node="%s" TTL="%s", Type="%s", RData="%s")' %
      [options[:dry_run] ? '(NOT) ' : '', options[:zone], options[:node], options[:ttl], options[:type], rdata.to_json])
    begin
      if not options[:dry_run]
        response = c.rest_call(:post, [Dynect::rtype_to_resource(options[:type]), options[:zone], options[:node]], { 'rdata' => rdata, 'ttl' => options[:ttl] })
      end
      changes += 1
    rescue Dynect::DynectError
      errors += 1
      log.error('Failed to add record - %s' % $!.message)
    end
  end

  # publish changes
  if changes > 0
    begin
      if options[:cancel_on_error] and errors > 0
        log.warn('%sCanceling changes' % [options[:dry_run] ? '(NOT) ' : ''])
        if not options[:dry_run]
          c.rest_call(:delete, [ 'ZoneChanges', options[:zone]])
        end
      else
        log.info('%sPublishing changes' % [options[:dry_run] ? '(NOT) ' : ''])
        if not options[:dry_run]
          c.rest_call(:put, [ 'Zone', options[:zone]], { 'publish' => 'true' })
        end
      end
    rescue Dynect::DynectError
      log.error($!.message)
    end
  else
    log.info('No changes made')
  end

  # terminate session
  log.info('Terminating session')
  begin
    c.rest_call(:delete, 'Session')
  rescue Dynect::DynectError
    log.error($!.message)
  end
end
